# from fastapi import FastAPI
# from app import auth, models, database
# from app.models import Task
# from app.schemas import TaskCreate
# from app.auth import get_current_user
# from fastapi.middleware.cors import CORSMiddleware
# from fastapi import Depends, HTTPException
# from sqlalchemy.orm import Session
# from app.ai_task_generator import generate_task
# from app.database import get_db

# models.Base.metadata.create_all(bind=database.engine)

# app = FastAPI()
# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )

# @app.get("/")
# def read_root():
#     return {"message": "Welcome to AI Task Manager"}


# from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey, create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship, Session
from pydantic import BaseModel
from typing import List, Optional
import openai
import os
from fastapi import FastAPI, Depends, HTTPException, status


DATABASE_URL = "postgresql://postgres:1234@localhost/taskdb"

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

app = FastAPI()

# SQLAlchemy models
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    password = Column(String)
    tasks = relationship("Task", back_populates="owner")

class Task(Base):
    __tablename__ = 'tasks'
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String)
    description = Column(String)
    completed = Column(Boolean, default=False)
    owner_id = Column(Integer, ForeignKey("users.id"))
    owner = relationship("User", back_populates="tasks")

# Pydantic schemas
class TaskBase(BaseModel):
    title: str
    description: Optional[str] = None
    completed: Optional[bool] = False

class TaskCreate(TaskBase):
    pass

class TaskOut(TaskBase):
    id: int
    class Config:
        orm_mode = True

class UserCreate(BaseModel):
    username: str
    password: str

class UserOut(BaseModel):
    id: int
    username: str
    class Config:
        orm_mode = True

# Dependency to get DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Routes
@app.post("/register", response_model=UserOut)
def register(user: UserCreate, db: Session = Depends(get_db)):
    db_user = db.query(User).filter(User.username == user.username).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Username already registered")
    new_user = User(username=user.username, password=user.password)
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user

@app.get("/tasks", response_model=List[TaskOut])
def get_tasks(db: Session = Depends(get_db)):
    return db.query(Task).all()

@app.post("/tasks", response_model=TaskOut)
def create_task(task: TaskCreate, db: Session = Depends(get_db)):
    new_task = Task(**task.dict(), owner_id=1)  # Replace with real user ID
    db.add(new_task)
    db.commit()
    db.refresh(new_task)
    return new_task

@app.post("/tasks/suggest", response_model=TaskOut)
def suggest_task(db: Session = Depends(get_db)):
    openai.api_key = os.getenv("")
    response = openai.Completion.create(
        engine="text-davinci-003",
        prompt="Suggest a productive task for a software engineer",
        max_tokens=50
    )
    suggestion = response.choices[0].text.strip()
    new_task = Task(title=suggestion, description="Generated by AI", owner_id=1)
    db.add(new_task)
    db.commit()
    db.refresh(new_task)
    return new_task

# Initialize DB tables
Base.metadata.create_all(bind=engine)
